#!/usr/bin/env python2
# -*- coding: utf-8 -*-

import sys
import os
import socket
import time
import json
import traceback
try:
	import better_exchook
except ImportError:
	pass
else:
	better_exchook.install()

import pulsectl
import threading
import glib
import gobject
import gtk
import hband_tools.gui as gui



APPNAME = 'paosd'
MainWindowHideTimeoutSec = 5.0
MainWindowDefaultWidthPx = 250
MediaStreamButtonDebounceSec = 0.6


class Timer(object):
	def __init__(self, timeout_sec, cb_func, *cb_args):
		self.timeout_sec = timeout_sec
		self.callback = cb_func
		self.cb_args = cb_args
		self.handle = None
	def start(self):
		self.handle = glib.timeout_add(int(self.timeout_sec * 1000), self.fire)
	def stop(self):
		if self.handle is not None:
			glib.source_remove(self.handle)
			self.handle = None
	def restart(self):
		self.stop()
		self.start()
	def fire(self):
		self.stop()
		self.callback(*self.cb_args)
	@property
	def winded_down(self):
		return self.handle is None


class GtkThreads(object):
	def __enter__(self):
		gtk.threads_enter()
	def __exit__(self, exc_type, exc, tb):
		gtk.threads_leave()


def listen_pulse_events():
	while State['run']:
		if State['pulse_listener'] is None: State['pulse_listener'] = pulsectl.Pulse(APPNAME+'.listen')
		State['pulse_listener'].event_mask_set('sink', 'client', 'sink_input')
		State['pulse_listener'].event_callback_set(on_pulse_event)
		try:
			State['pulse_listener'].event_listen(timeout=None)
		except pulsectl.PulseDisconnected:
			State['pulse_listener'] = None
		except:
			pass

def on_pulse_event(event):
	glib.idle_add(on_pulse_event_in_gtk_thread, priority=glib.PRIORITY_DEFAULT_IDLE)

InfoDisplayedPerDevice = {}

def on_pulse_event_in_gtk_thread():
	pa_sinks = pulseproxy.sink_list()
	for pa_sink in pa_sinks:
		sink_desc = pa_sink.description
		port_desc = pa_sink.port_active.description
		volume = int(pa_sink.volume.value_flat * 100)
		device_key = (sink_desc, port_desc)
		device_info = (pa_sink.mute, volume)
		if InfoDisplayedPerDevice.get(device_key, (None, None)) != device_info:
			with GtkThreads():
				main_win.update(pa_sink, label = sink_desc + " ➤ " + port_desc, muted = pa_sink.mute, volume = volume)
			InfoDisplayedPerDevice[device_key] = device_info
			# TODO update window even when the sink port changes
	media_streams_per_sink = {}
	for media_stream in pulseproxy.sink_input_list():
		sink_name = pulseproxy.sink_info(index=media_stream.sink).name
		if sink_name not in media_streams_per_sink: media_streams_per_sink[sink_name] = []
		media_streams_per_sink[sink_name].append({
			'sink_input_index': media_stream.index,
			'name': media_stream.name,
			'prog': media_stream.proplist['application.name'],
			'pid':  media_stream.proplist['application.process.id'],
			'icon': media_stream.proplist['application.icon_name'],
		})
	with GtkThreads():
		for pa_sink in pa_sinks:
			main_win.update_silent(pa_sink, media_streams = media_streams_per_sink.get(pa_sink.name, []))
		global_media_stream_pool.cleanup()


class VolumeWindow(gui.Window):
	__gsignals__ = {
		'media-stream-boxes-width-changed': (gobject.SIGNAL_RUN_LAST, gobject.TYPE_NONE, (gobject.TYPE_INT,)),
	}
	
	def __init__(self):
		self.hide_timer = Timer(MainWindowHideTimeoutSec, self.hide)
		self.device_box = {}
		
		super(VolumeWindow, self).__init__({'name': 'window.main', 'default-size': (MainWindowDefaultWidthPx, -1), 'gtk-args': [gtk.WINDOW_TOPLEVEL]})
		self.set_decorated(False)
		self.set_skip_taskbar_hint(True)
		self.set_skip_pager_hint(True)
		self.set_keep_above(True)
		self.set_accept_focus(False)
		self.set_type_hint(gtk.gdk.WINDOW_TYPE_HINT_UTILITY)
		self.set_resizable(True)
		
		self.add_events(gtk.gdk.BUTTON_RELEASE_MASK | gtk.gdk.ENTER_NOTIFY_MASK | gtk.gdk.LEAVE_NOTIFY_MASK)
		self.connect_after('button-release-event', self.on_mouse_button_release)
		self.connect_after('enter-notify-event', self.on_pointer_enter)
		self.connect_after('leave-notify-event', self.on_pointer_leave)
		
		frame = gtk.Frame()
		frame.set_shadow_type(gtk.SHADOW_OUT)
		self.add(frame)
		self.vbox = gtk.VBox(homogeneous=True, spacing=3)
		frame.add(self.vbox)
		
		self._media_stream_boxes_width = 0
		self.media_streams_boxes_sizegroup = gtk.SizeGroup(gtk.SIZE_GROUP_HORIZONTAL)
		self.property_persistor.add_properties([
			('media-stream-boxes-width', 'media-stream-boxes-width-changed', lambda widget, width: width, lambda widget, width: None)
		])
		media_stream_boxes_width_saved = self.property_persistor.props.get('media-stream-boxes-width')
		if media_stream_boxes_width_saved is not None:
			W, H = self.get_size()
			gobject.idle_add(self.resize, W - media_stream_boxes_width_saved + 1, H)
	
	def on_mouse_button_release(self, widget, event):
		if event.button != gui.MOUSE_BUTTON_RIGHT: return
		self.hide_timer.stop()
		self.hide()
	
	def on_pointer_enter(self, widget, event):
		self.hide_timer.stop()
	
	def on_pointer_leave(self, widget, event):
		if event.detail in [gtk.gdk.NOTIFY_NONLINEAR]:
			self.hide_timer.start()
	
	def popup(self):
		self.hide_timer.restart()
		self.show_all()
	
	def update(self, pa_sink, **args):
		self.update_silent(pa_sink, **args)
		self.popup()
	
	def update_silent(self, pa_sink, **args):
		if pa_sink.name not in self.device_box.keys():
			self.device_box[pa_sink.name] = AudioDeviceBox(pa_sink, self)
			self.vbox.pack_start(self.device_box[pa_sink.name], expand=False, padding=0)
		self.device_box[pa_sink.name].update(**args)
	
	@property
	def media_stream_boxes_width(self):
		return self._media_stream_boxes_width
	
	@media_stream_boxes_width.setter
	def media_stream_boxes_width(self, new):
		self._media_stream_boxes_width = new
		self.emit('media-stream-boxes-width-changed', new)
	
	def on_media_stream_box_size_change(self, widget, allocation):
		new_width = allocation.width
		diff = new_width - self.media_stream_boxes_width
		self.media_stream_boxes_width = new_width
		if diff != 0:
			W, H = self.get_size()
			gobject.idle_add(self.resize, W + diff, H)
		return False
	
	def add_media_streams_boxes_widget(self, widget):
		self.media_streams_boxes_sizegroup.add_widget(widget)


class AudioDeviceBox(gtk.VBox):
	def __init__(self, sink, parent):
		self.pa_sink = sink
		self.muted = None
		self._parent = parent
		
		super(AudioDeviceBox, self).__init__(homogeneous=False, spacing=0)
		hbox = gtk.HBox(homogeneous=False, spacing=5)
		self.pack_start(hbox, expand=False, padding=0)
		
		self.mute_button = gtk.ToolButton()
		self.mute_button.connect('clicked', self.on_mute_button_click)
		self.voltext = gtk.Label()
		self.voltext.set_width_chars(5)
		
		self.slider = gtk.HScale(gtk.Adjustment(value=0.0, lower=0.0, upper=100.0, step_incr=-1.0, page_incr=10.0, page_size=0.0))
		self.slider.set_update_policy(gtk.UPDATE_CONTINUOUS)
		self.slider.set_draw_value(False)
		self.slider.set_inverted(False)
		self.slider.connect('change-value', self.on_slider_change)
		self.slider.connect('value-changed', self.on_slider_changed)
		
		# TODO add set-default radio button
		
		self.media_streams_box = MediaStreamsBox(parent=self)
		self._parent.add_media_streams_boxes_widget(self.media_streams_box)
		self.label = gtk.Label()
		self.label.set_alignment(0, 0.5)
		
		# TODO sink_port selector
		
		hbox.pack_start(self.mute_button, expand=False, padding=0)
		hbox.pack_start(self.voltext, expand=False, padding=0)
		hbox.pack_start(self.slider, expand=True, fill=True, padding=0)
		hbox.pack_start(self.media_streams_box, expand=False, padding=0)
		self.pack_start(self.label, expand=False, padding=0)
		self.show_all()
	
	def on_mute_button_click(self, button):
		pulseproxy.mute(self.pa_sink, not self.muted)
	
	def on_slider_change(self, range_obj, scroll_type, value):
		if value >= 0:
			pulseproxy.volume_set_all_chans(self.pa_sink, value/100)
		return False
	
	def on_slider_changed(self, range_obj):
		self.voltext.set_text('%d%%' % range_obj.get_value())
	
	def update(self, **args):
		if 'volume' in args:
			self.slider.set_value(args['volume'])
		if 'muted' in args:
			self.update_mute_button(args['muted'])
		if 'label' in args:
			self.label.set_text(args['label'])
		if 'media_streams' in args:
			self.media_streams_box.update_streams(args['media_streams'])
	
	def update_mute_button(self, muted):
		self.muted = muted
		volume = self.slider.get_value()
		if muted or volume <= 0: icon_variant = 'mute'
		elif volume < 33:        icon_variant = 'min'
		elif volume < 66:        icon_variant = 'med'
		else:                    icon_variant = 'max'
		self.mute_button.set_icon_name('stock_volume-%s' % icon_variant)


class MediaStreamsBox(gtk.HBox):
	def __init__(self, parent=None):
		self._devicebox = parent
		super(MediaStreamsBox, self).__init__(homogeneous=True, spacing=2)
		self.connect('size-allocate', self._devicebox._parent.on_media_stream_box_size_change)
	
	def __repr__(self):
		return "<%s sink=%s>" % (self.__class__.__name__, self._devicebox.pa_sink.name)
	
	def update_streams(self, my_streams):
		my_streams_ids = []
		for stream in my_streams:
			global_media_stream_pool.update(stream, self)
			my_streams_ids.append( global_media_stream_pool.get_id(stream) )
		for media_stream_id in global_media_stream_pool.get_media_stream_ids_owned_by(self):
			if media_stream_id not in my_streams_ids:
				global_media_stream_pool.relinquish(media_stream_id, self)
	
	def assign_media_stream_button(self, widget):
		self.pack_start(widget, expand=False, padding=0)
		self.show_all()
		self._devicebox._parent.popup()


class MediaStreamPool(object):
	def __init__(self):
		self.stream_symbols = {}
	
	def get_media_stream_ids_owned_by(self, owner):
		return [ key for key in self.stream_symbols.keys() if self.stream_symbols[key]['owner'] is owner ]
	
	def get_id(self, media_stream):
		return media_stream['sink_input_index']
	
	def update(self, media_stream, new_owner):
		sink_input_index = self.get_id(media_stream)
		if sink_input_index not in self.stream_symbols.keys():
			debounce_timer = Timer(MediaStreamButtonDebounceSec, self.manifestate, sink_input_index)
			self.stream_symbols[sink_input_index] = {
				'owner': new_owner,
				'widget': MediaStreamButton(media_stream),
				'debounce-timer': debounce_timer,
			}
			debounce_timer.start()
		else:
			stream_symbol = self.stream_symbols[sink_input_index]
			old_owner = stream_symbol['owner']
			if old_owner is not new_owner:
				self.relinquish(sink_input_index, old_owner)
				stream_symbol['owner'] = new_owner
				if stream_symbol['debounce-timer'].winded_down:
					self.manifestate(sink_input_index)
			stream_symbol['widget'].update(media_stream)
	
	def manifestate(self, sink_input_index):
		stream_symbol = self.stream_symbols[sink_input_index]
		owner = stream_symbol['owner']
		if owner is not None:
			owner.assign_media_stream_button(stream_symbol['widget'])
	
	def relinquish(self, sink_input_index, old_owner):
		if old_owner is None: return
		stream_symbol = self.stream_symbols[sink_input_index]
		if stream_symbol['owner'] is old_owner:
			if stream_symbol['widget'] in old_owner.get_children():
				old_owner.remove(stream_symbol['widget'])
			stream_symbol['owner'] = None
	
	def cleanup(self):
		for sink_input_index, stream_symbol in self.stream_symbols.items():
			if stream_symbol['owner'] is None:
				stream_symbol['debounce-timer'].stop()
				stream_symbol['widget'].destroy()
				del self.stream_symbols[sink_input_index]


class MediaStreamButton(gtk.ToggleButton):
	def __init__(self, media_stream):
		self.sink_input_index = media_stream['sink_input_index']
		super(MediaStreamButton, self).__init__()
		self._programatic_state_change_in_progress = None
		self.connect('clicked', self.on_clicked)
		self.set_image(gtk.Image())
		self.update(media_stream)
	
	def set_icon_name(self, icon_name):
		self.get_image().set_from_icon_name(icon_name, gtk.ICON_SIZE_LARGE_TOOLBAR)
	
	@property
	def sink_input(self):
		return pulseproxy.sink_input_info(self.sink_input_index)
	
	def on_clicked(self, widget):
		if not self._programatic_state_change_in_progress:
			pulseproxy.sink_input_mute(self.sink_input.index, not self.get_active())
	
	def set_active(self, active_state):
		self._programatic_state_change_in_progress = True
		super(MediaStreamButton, self).set_active(active_state)
		self._programatic_state_change_in_progress = False
	
	def update(self, media_stream):
		self.set_icon_name(gtk.STOCK_MEDIA_PLAY)
		#DnD to change sink...
		if media_stream.get('icon'):
			self.set_icon_name(media_stream['icon'])
		try:
			self.set_active(not self.sink_input.mute)
		except pulsectl.pulsectl.PulseError:
			pass
		self.set_tooltip_text(media_stream.get('prog', '') + ' ➤ ' + media_stream.get('name', ''))


class PulseProxy(object):
	def __init__(self):
		self._pa = None
	def _connect(self):
		if self._pa is None or not self._pa.connected:
			self._pa = pulsectl.Pulse(APPNAME+'.control')
	def __getattr__(self, name):
		self._connect()
		return getattr(self._pa, name)
	def __setattr__(self, name, value):
		if name.startswith('_'):
			object.__setattr__(self, name, value)
		else:
			self._connect()
			setattr(self._pa, name, value)



State = {
	'run': True,
	'pulse_listener': None,
}


pulseproxy = PulseProxy()

gtk.gdk.threads_init()
pulse_listen_thr = threading.Thread(target=listen_pulse_events, name='Pulse listener')
pulse_listen_thr.setDaemon(True)
pulse_listen_thr.start()

global_media_stream_pool = MediaStreamPool()
main_win = VolumeWindow()
main_win.hide()
try:
	gtk.main()
except KeyboardInterrupt:
	pass

State['run'] = False
if State['pulse_listener'] is not None: State['pulse_listener'].disconnect()
pulse_listen_thr.join()
