#!/usr/bin/env python2

import sys
import os
import socket
import time
import json
import traceback
try:
	import better_exchook
except ImportError:
	pass
else:
	better_exchook.install()

import pulsectl
import threading
import glib
import gtk
import hband_tools.gui as gui



APPNAME = 'paosd'


class Timer(object):
	def __init__(self, timeout_sec, cb_func, *cb_args):
		self.timeout_sec = timeout_sec
		self.callback = cb_func
		self.cb_args = cb_args
		self.handle = None
	def start(self):
		self.handle = glib.timeout_add(int(self.timeout_sec * 1000), self.fire)
	def stop(self):
		if self.handle is not None:
			glib.source_remove(self.handle)
			self.handle = None
	def restart(self):
		self.stop()
		self.start()
	def fire(self):
		self.stop()
		self.callback(*self.cb_args)


def listen_pulse_events():
	while State['run']:
		if State['pulse_listener'] is None: State['pulse_listener'] = pulsectl.Pulse(APPNAME+'.listen')
		State['pulse_listener'].event_mask_set('sink')
		State['pulse_listener'].event_callback_set(on_pulse_event)
		try:
			State['pulse_listener'].event_listen(timeout=None)
		except pulsectl.PulseDisconnected:
			State['pulse_listener'] = None
		except:
			pass

def on_pulse_event(event):
	glib.idle_add(on_pulse_event_in_gtk_thread, priority=glib.PRIORITY_DEFAULT_IDLE)

def on_pulse_event_in_gtk_thread():
	for sink in pulseproxy.sink_list():
		sink_desc = sink.description
		port_desc = sink.port_active.description
		muted = sink.mute
		volume = sink.volume.value_flat * 100
		volume = int(volume)
		display_volume(sink, sink_desc, port_desc, muted, volume, sink.state._value == 'running')

InfoDisplayedPerDevice = {}

def display_volume(pa_sink, device, device_port, muted, volume, has_activity):
	key = (device, device_port)
	info = (muted, volume)
	if InfoDisplayedPerDevice.get(key, (None, None)) != info:
		gtk.threads_enter()
		main_win.update(pa_sink, label = device + " - " + device_port, muted = muted, volume = volume)
		gtk.threads_leave()
		InfoDisplayedPerDevice[key] = info
	main_win.update_silent(pa_sink, has_activity = has_activity)


class VolumeWindow(gui.Window):
	def __init__(self):
		self.hide_timer = Timer(5.0, self.hide)
		self.volume_meter = {}
		
		super(VolumeWindow, self).__init__({'name': 'window.main', 'gtk-args': [gtk.WINDOW_TOPLEVEL]})
		self.set_decorated(False)
		self.set_skip_taskbar_hint(True)
		self.set_skip_pager_hint(True)
		self.set_keep_above(True)
		self.set_accept_focus(False)
		self.set_type_hint(gtk.gdk.WINDOW_TYPE_HINT_UTILITY)
		
		self.add_events(gtk.gdk.BUTTON_RELEASE_MASK | gtk.gdk.ENTER_NOTIFY_MASK | gtk.gdk.LEAVE_NOTIFY_MASK)
		self.connect_after('button-release-event', self.on_mouse_button_release)
		self.connect_after('enter-notify-event', self.on_pointer_enter)
		self.connect_after('leave-notify-event', self.on_pointer_leave)
		
		frame = gtk.Frame()
		frame.set_shadow_type(gtk.SHADOW_OUT)
		self.add(frame)
		self.vbox = gtk.VBox(homogeneous=False, spacing=3)
		frame.add(self.vbox)
	
	def on_mouse_button_release(self, widget, event):
		if event.button != gui.MOUSE_BUTTON_RIGHT: return
		self.hide_timer.stop()
		self.hide()
	
	def on_pointer_enter(self, widget, event):
		self.hide_timer.stop()
	
	def on_pointer_leave(self, widget, event):
		if event.detail in [gtk.gdk.NOTIFY_NONLINEAR]:
			self.hide_timer.start()
	
	def update(self, pa_sink, **args):
		self.update_silent(pa_sink, **args)
		self.hide_timer.restart()
		self.show_all()
	
	def update_silent(self, pa_sink, **args):
		if pa_sink.name not in self.volume_meter:
			self.volume_meter[pa_sink.name] = AudioDeviceMeterBox(pa_sink)
			self.vbox.pack_start(self.volume_meter[pa_sink.name], expand=False, fill=False, padding=0)
		self.volume_meter[pa_sink.name].update(**args)


class AudioDeviceMeterBox(gtk.VBox):
	def __init__(self, sink):
		self.pa_sink = sink
		self.muted = None
		
		super(AudioDeviceMeterBox, self).__init__(homogeneous=False, spacing=0)
		hbox = gtk.HBox(homogeneous=False, spacing=5)
		self.pack_start(hbox, expand=False, fill=False, padding=0)
		
		self.icon = gtk.ToolButton()
		self.icon.connect('clicked', self.on_icon_click)
		self.voltext = gtk.Label()
		self.voltext.set_width_chars(5)
		
		self.slider = gtk.HScale(gtk.Adjustment(value=0.0, lower=0.0, upper=100.0, step_incr=-1.0, page_incr=10.0, page_size=0.0))
		self.slider.set_update_policy(gtk.UPDATE_CONTINUOUS)
		self.slider.set_draw_value(False)
		self.slider.set_inverted(False)
		self.slider.set_size_request(120, 0)
		self.slider.connect('change-value', self.on_slider_change)
		self.slider.connect('value-changed', self.on_slider_changed)
		
		self.activity_indicator = gui.Image()
		self.activity_indicator.set_size_request(*gtk.icon_size_lookup(gtk.ICON_SIZE_SMALL_TOOLBAR))
		self.label = gtk.Label()
		self.label.set_alignment(0, 0.5)
		
		hbox.pack_start(self.icon, expand=False, fill=False, padding=0)
		hbox.pack_start(self.voltext, expand=False, fill=False, padding=0)
		hbox.pack_start(self.slider, expand=True, fill=True, padding=0)
		hbox.pack_start(self.activity_indicator, expand=False, fill=False, padding=0)
		self.pack_start(self.label, expand=True, fill=True, padding=0)
		self.show_all()
	
	def on_icon_click(self, button):
		pulseproxy.mute(self.pa_sink, not self.muted)
	
	def on_slider_change(self, range_obj, scroll_type, value):
		if value >= 0:
			pulseproxy.volume_set_all_chans(self.pa_sink, value/100)
		return False
	
	def on_slider_changed(self, range_obj):
		self.voltext.set_text('%d%%' % range_obj.get_value())
	
	def update(self, **args):
		if 'volume' in args:
			self.slider.set_value(args['volume'])
		if 'muted' in args:
			self.update_icon(args['muted'])
		if 'label' in args:
			self.label.set_text(args['label'])
		if 'has_activity' in args:
			self.set_has_activity(args['has_activity'])
	
	def update_icon(self, muted):
		self.muted = muted
		volume = self.slider.get_value()
		if muted or volume <= 0: icon_variant = 'mute'
		elif volume < 33:        icon_variant = 'min'
		elif volume < 66:        icon_variant = 'med'
		else:                    icon_variant = 'max'
		self.icon.set_icon_name('stock_volume-%s' % icon_variant)
	
	def set_has_activity(self, has_activity):
		if has_activity:
			self.activity_indicator.icon = (gtk.STOCK_MEDIA_PLAY, gtk.ICON_SIZE_SMALL_TOOLBAR)
		else:
			self.activity_indicator.clear()


class PulseProxy(object):
	def __init__(self):
		self._pa = None
	def _connect(self):
		if self._pa is None or not self._pa.connected:
			self._pa = pulsectl.Pulse(APPNAME+'.control')
	def __getattr__(self, name):
		self._connect()
		return getattr(self._pa, name)
	def __setattr__(self, name, value):
		if name.startswith('_'):
			object.__setattr__(self, name, value)
		else:
			self._connect()
			setattr(self._pa, name, value)



State = {
	'run': True,
	'pulse_listener': None,
}


pulseproxy = PulseProxy()

gtk.gdk.threads_init()
pulse_listen_thr = threading.Thread(target=listen_pulse_events, name='Pulse listener')
pulse_listen_thr.setDaemon(True)
pulse_listen_thr.start()

main_win = VolumeWindow()
main_win.hide()
try:
	gtk.main()
except KeyboardInterrupt:
	pass

State['run'] = False
if State['pulse_listener'] is not None: State['pulse_listener'].disconnect()
pulse_listen_thr.join()
